## 1. 通用数据帧格式

**重要: 所有多字节字段 (SOF, payload length, CRC16, 以及payload中的多字节数据) 均采用小端模式 (Little-Endian) 传输。**

| 字段 | | | 长度 (Bytes) | 描述 |
| --- | --- | --- | :--- | :--- |
| SOF | | | 2 | 起始帧 (Start of Frame): `0xAA55`<br/>按字节打包时遵循小端模式为 55 AA |
| MSG | info | Source | 1 | 源地址 (见 1.1) |
| | | Target | 1 | 目标地址 (见 1.1) |
| | | MSG ID | 1 | 命令码，定义操作的大类 |
| | | payload length | 2 | `Data` 字段的字节长度 (小端模式) |
| | payload | | N | 数据负载，用于传递具体参数或子命令 |
| CRC16 | | | 2 | 对 MSG 字段进行 CRC16-CCITT-FALSE 校验 |
| EOF | | | 2 | 结束帧 (End of Frame): `0x66BB`<br/>按字节打包时遵循小端模式为 BB 66 |


## 5. 测试工装 (Tooling) <-> 被测底板 (Device) 协议
**设计思想**: 工装向下发送原子化的、底层的硬件遥控指令。底板固件只需实现这些基本操作，无需关心复杂的测试流程。

### 5.1. 同端口IO批量控制 (`MSG ID = 0x10`)
**功能**: 对**单个端口**下的**多个GPIO引脚**进行精细化操作，类似PCA9555。`

** 工装 -> 底板, **`payload`**结构:** 

`[Sub-ID (1B)] [Port ID (1B)] [Pin Mask (2B)] [Value (1B)]`

| `Sub-ID` | 描述 | `Pin Mask` (u16) | `Value` (u8) 参数 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| `0x01` | **设置引脚模式** | 16位掩码，`1`代表选中该引脚 | `0x00`: 输入, `0x01`: (推挽)输出, `0x02`: 模拟 | 将掩码选中的所有引脚设为同一种模式(payload长5B) |
| `0x02` | **配置上下拉** | 16位掩码，`1`代表选中该引脚 | `0x00`: 下拉, `0x01`: 上拉, `0x02`: 无/浮空 | 将掩码选中的所有引脚设为同一种上下拉状态(payload长5B) |
| `0x03` | **写输出电平** | 16位掩码，`1`代表选中该引脚 | `0x00`: Low, `0x01`: High | 将掩码选中的所有输出引脚设为同一种电平(payload长5B) |
| `0x04` | **读输入电平** | (无) | (无) | 读取该端口下全部16个引脚的电平状态(payload长2B) |


****

**底板 -> 工装, **`payload`** 结构:**

+ 对于**写/配置操作** (`Sub-ID` = 0x01, 0x02, 0x03)，`payload` 结构为: `[Sub-ID (1B)] [Status (1B)]`  
`Status`** 字节定义:**

| `Status` 值 | 枚举名 | 描述 |
| :--- | :--- | :--- |
| `0x00` | `DEVICE_OK` | 指令成功执行 |
| `0x01` | `DEVICE_ERR_INVALID_PORT` | 无效的端口号 |
| `0x02` | `DEVICE_ERR_INVALID_PIN` | 无效的引脚掩码 |
| `0x03` | `DEVICE_ERR_INVALID_SUB_ID` | 无效的子命令ID |
| `0x04` | `DEVICE_ERR_EXECUTION` | 其他执行时错误 |


+ 对于**读操作** (`Sub-ID` = 0x04)，`payload` 结构为: `[Sub-ID (1B)] [Port ID (1B)] [Levels (2B)]`  
底板在收到读指令后，应返回一个特殊的响应帧：
+ `payload`: `[Sub-ID (1B)] [Port ID (1B)] [Levels (2B)]`
    - `Sub-ID`: `0x04`
    - `Port ID`: 请求的端口ID
    - `Levels`: 该端口所有16个引脚的电平状态 `u16` 掩码。（小端）

****

**示例**: 设置 PC8 和 PC9 为推挽输出

工装端的`payload`: 

`[0x01 (Set Mode)] [0x02 (PortC)] [0x0300 (Mask for PC8, PC9)] [0x01 (Push-Pull)]`

最终向底板发送的数据包为： 55 AA | 01 02 | 10 | 05 00 | 01 02 **00 03** 01 | 40 02 | BB 66



底板端的`payload`: 

`[0x01 (Set Mode)] [0x00 (Status OK)]`

底板参考回复： 55 AA | 02 01 | 10 | 02 00 | 01 00 | 8E 0E | BB 66



**示例2：**控制PC8与PC9输出高电平（当前引脚已经为输出模式时）

工装端的`payload`: 

`[0x03 (Write Level)] [0x02 (PortC)] [0x0300 (Mask for PC8, PC9)] [0x01 (High)]`

最终向底板发送的数据包为： 55 AA | 01 02 | 10 | 05 00 | 03 02 **00 03** 01 | C3 46 | BB 66



底板端的`payload`: 

`[0x03 (Write Level)] [0x00 (Status OK)]`

底板参考回复： 55 AA | 02 01 | 10 | 02 00 | 03 00 | EC 68 | BB 66



**示例3：**读取PORT C全部16引脚输入电平（需要先配好上下拉）

工装端的`payload`: 

`[0x04 (Read Level)] [0x02 (PortC)]`

最终向底板发送的数据包为： 55 AA | 01 02 | 10 | 02 00 | 04 02 | 5B C7 | BB 66



底板端的`payload`: 

`[0x04 (Read Level)] [0x02 (PortC)] [Levels (2B)]`

底板参考回复： 55 AA | 02 01 | 10 | 04 00 | 04 02 FF FE | A3 01 | BB 66

*回复中端口电平为u16掩码，因此最终解析结果为FEFF,表示只有PC9为低，其余15个全为高

### 5.2. 特殊外设IO批量控制 (`MSG ID = 0x11`)
+ **功能**: 对**指定外设**的多个GPIO引脚进行位掩码形式的批量操作，适用于64路IO与8位拨码开关等场景。
+ `payload`** 字段结构**: `[Sub-ID (1B)] [Target ID (1B)] [Pin Mask (N B)] [Value (1B)]`
    - `Target ID`: 用于区分不同的硬件模块。
        * `0x01`: 64路IO模块 (`Pin Mask` 长度 N=8)
        * `0x02`: 8位拨码开关 (`Pin Mask` 长度 N=1)
    - `Pin Mask`: 具体的控制掩码。
+ **除了PORT换为Target ID，以及IO顺序为底板丝印外，其余规则与0x10指令一致。**

| `Sub-ID` | 描述 | `Pin Mask` (u64/u8) | `Value` (u8) 参数 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| `0x01` | **设置引脚模式** | 引脚掩码，`1`代表选中该引脚 | `0x00`: 输入, `0x01`: (推挽)输出, `0x02`: 模拟 | 将掩码选中的所有引脚设为同一种模式 |
| `0x02` | **配置上下拉** | 引脚掩码，`1`代表选中该引脚 | `0x00`: 下拉, `0x01`: 上拉, `0x02`: 无/浮空 | 将掩码选中的所有引脚设为同一种上下拉状态 |
| `0x03` | **写输出电平** | 引脚掩码，`1`代表选中该引脚 | `0x00`: Low, `0x01`: High | 将掩码选中的所有输出引脚设为同一种电平 |
| `0x04` | **读输入电平** | (无) | (无) | 读取该端口下全部16个引脚的电平状态 |




底板 -> 工装, 回复帧 (Response Frame):

+ 对于写/配置操作，`payload` 结构为: `[Sub-ID (1B)] [Target ID (1B)] [Status (1B)]`
+ 对于读操作 (`Sub-ID` = 0x04)，`payload` 结构为: `[Sub-ID (1B)] [Target ID (1B)] [Mask (N B)]`



示例：

测试拨码开关-工装与底板间通信

配置8个引脚全为输入

工装 -> 底板：55 AA 01 02 | 11 | 04 00 | **01(设置模式)** **02(拨码开关) FF(8个引脚) 00(输入模式)** | 67 EE BB 66

底板 -> 工装：55 AA 02 01 11 03 00 01 02 **00(OK)** 5D E6 BB 66

配置8个引脚全为上拉

工装 -> 底板：55 AA 01 02 11 04 00 02 02 FF 01 9A 65 BB 66

底板 -> 工装：55 AA 02 01 11 03 00 02 02 00 0D BF BB 66

读取8个引脚当前电平

工装 -> 底板：55 AA 01 02 11 | 02 00 | 04 02 | 0A 6D BB 66

底板 -> 工装：55 AA 02 01 11 | 03 00 | 04 02 5A | 12 F6 BB 66

### 5.3. 执行封装测试 (`MSG ID = 0x30`)
+ **功能**: 触发底板固件中预先编写好的、无法通过简单遥控完成的复杂测试流程。

| `Sub ID` | 描述 | 工装发送的 `payload` | 底板回复的 `payload` |
| :--- | :--- | :--- | :--- |
| `0x01` | 串口回环自测 | `[Sub ID (0x01)]` | `[Sub ID (0x01)] [Status (1B)]` |
| `0x02` | 下发SN码 | `[Sub ID (0x11)] [SN Length (1B)] [SN_String (NB)]` | `[Sub ID (0x02)] [Status (1B)]` |
| `0x10` | 读取唯一ID | `[Sub ID (0x10)]` | `[Sub ID (0x10)] [ID Length (1B)][ID_Data (NB)]` |
| `0x11` | 读取SN码 | `[Sub ID (0x11)]` | `[Sub ID (0x11)] [SN Length (1B)] [SN_String (NB)]` |
| `0x12` | 读取固件版本 | `[Sub ID (0x12)]` | `[Sub ID (0x12)] [FW Length (1B)][FW_Version (NB)]` |
| `...` |  |  |  |


### 5.4. 心跳与状态查询 (`MSG ID = 0x0F`)
+ **功能**: 用于工装主动查询底板是否在线及其基本状态。
+ `payload`** (工装 -> 底板)**: (无)
+ `payload`** (底板 -> 工装)**: `[status (1B)]`

| `status` | 描述 |
| :--- | :--- |
| `0x00` | **OK**: 初始化完成，空闲待机 |
| `0x01` | **BUSY**: 正在执行任务 |
| `0xFF` | **ERROR**: 发生未知错误 |


示例：

工装->底板：55 AA 01 02 0F 00 00 04 7A BB 66

底板->工装：55 AA 02 01 0F 01 00 **FF** 2F D2 BB 66（错误）

55 AA 02 01 0F 01 00 **00** DF CC BB 66(正常)